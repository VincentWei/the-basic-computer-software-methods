# 第 4 章  文字：字符集、编码  

计算机程序的运算有了结果就要输出给人看，且应以便于人类认知的方式来展示结果。最好的方式就是使用人类使用的文字来输出结果了。然而，人类文明的发展丰富多样，语言文字变化多端。对计算机来讲，正确表达不同的文字信息是需要首先解决的问题。本章讲述文字这类信息的计算机表述方法。  

## 4.1  文字的编码需求  

为了形象地描述使用计算机表述文字的历史演进过程，我们在这一小节引入两个主人公小明和李教授。小明在一所大学的电子工程实验室做自己的本科论文，李教授是他的导师。  

小明这会儿正在使用纸带编写一段可连续打印圆周率的程序，这段程序源源不断地在纸带上打眼来输出二进制的圆周率。小明马上发现，二进制的数字得转换成十进制看呀，否则李教授怎么知道我这程序的输出是正确的？起码就现在大家都知道的圆周率小数点后十几位：“山巅一寺一壶酒（3.14159），尔乐苦煞吾（26535），把酒吃（897），酒杀尔（932），杀不死（384），乐尔乐（626）”，这程序要能正确输出吧？  

为了实现这个目标，小明编写了一段程序，把圆周率的二进制表达变成了十进制的表达，每个字节表达一个十进制数，哦，还有小数点。反正就十一个字符，小明就用0x00 表示十进制 0，0x01 表示 1，0x02 表示 2，依此类推，然后用 0x10 表示小数点。这下，程序输出的圆周率就变成了：   
 
```
0x03 0x10 0x01 0x04 …  
```  

但使用计算机，怎么把这个结果展示出来呢？要知道，那时的计算机可没有显示屏呀。小明很聪明，懂数字电路，他很快又搭了一个可以发光的数码管电路，这个电路根据 0x00 到 0x10 这几个数字，可以使用八段数码管显示十进制的 0 ~ 9 数字还有小数点。当小明的程序运行起来的时候，这个数码管从 3 开始，每隔一秒显示圆周率十进制表示的下个数字[^1]以及可能的小数点。  

李教授看到小明的工作成果非常开心，李教授大大表扬了小明，称小明的这个发明是划时代的，这让计算机有了一种能力，可以用人类能够理解的方式来表达自己。嗯，的确有点意思。最终，小明凭这个作品拿到了本科学位并开始在李教授的项目组攻读研究生。  

小明上研究生的头一天，李教授给了他一个题目，说现在有录音机了，可以录制和播放人的声音。你不是读过香农的信息论吗？看看能不能用磁带把你的计算好的圆周率录下来，将来也好给别人看呀。  

小明很快将这个功能实现了，原理很简单，就是把计算好的圆周率结果录制到磁带上，用二进制方式，每个磁粉的极性表示二进制的 0 或者 1。小明甚至把自己的名字还有李教授的名字所使用的拼音字母（包括空格）也编了码，比如 0xA1 表示 a，0xA2 表示 b，依此类推。一起放到了录制好的磁带上，“THE PI IS CALCULATED BY A PROGRAM WRITTEN BY XIAO MING AND DIRECTED BY PROFESSOR LI.”  

小明花了一年时间就把这项工作做完了，很快申请论文的答辩。作为研究生科研成果一部分，这磁带被寄给了小明研究生论文的评审教授王教授那里。王教授很欣赏这项工作，认为这项成果不仅仅可以用来记录程序的输出，甚至连同程序自身在内，亦可用磁带录制。不过王教授对录制的内容中没有出现自己的名字而感到不悦。于是，王教授告诉小明，你这项工作成果还不错，但尚不足以申请硕士学位论文，因为没有理论支撑啊！你需要将你的编码方法系统化，而且利于计算机处理。  

小明很是郁闷，本来可以提前毕业去工作挣钱，那时的英特尔公司刚刚成立正在招人哩。要是丧失了这个机会，就没法成为创始员工了。李教授劝他，计算机行业刚刚开始，以后机会多得是，你好好把自己的成果拔拔高，将来一旦成名，那机会就自己找上门来了。  

小明开始仔细琢磨王教授的评语，琢磨好几天没有头绪。有一日，小明跑到学校的图书馆，看到有人正在使用打字机打印求职信。小明一下子豁然开朗，我为什么不能将打字机和计算机连起来？打字机作为计算机的输入，把打字机上的每个按键编个号，程序记录这些编号，这样就可以直接用打字机来输入程序，然后执行，再将程序执行结果输出到磁带上。  

于是，小明快速设计了计算机使用的键盘，这个键盘可以将用户的每个按键进行编码并传输到计算机中进行处理。在之前的基础上，小明扩充了若干控制字符，比如回车啊，换行之类的，而且还区分了英文的大小写字母，添加了常用的标点符号。  

简单来说，小明的这个编码系统使用七个比特位来表示一个字符，取值范围为 0x00 到 0x7F，可以表示回车、换行、缩进（TAB）等控制字符，也可以表示 26 个拉丁字母（区分大小写），还包括十进制阿拉伯数字以及常用的标点符号。  

为什么使用七位呢？小明多次实验发现，将键盘通过一条线连接到计算机上时，因为这根线传输距离长，而且没有屏蔽层保护，传输的比特位经常会出现错误的情形。为此，小明使用了我们在第二章中所说的“奇偶校验”方法，将一个字节的最高位作为偶校验码传输过去。计算机收到一个字节后，如果不符合偶校验规则，则认为传输失败，键盘灯就会亮一下，提醒敲键盘的人再次输入。这样，就只能使用字节的低七位来编码了。但同时，小明的硕士论文一下子就高大上了！有工程方法还有理论依据，而且小明还将自己的硕士论文全部使用打字机录入然后保存在了磁带上。虽然王教授的名字最终只是出现在了论文的致谢部分，但王教授也没啥可说的，毕竟只是硕士论文嘛。最终，小明欢欢喜喜拿到了硕士学位，走向社会，大踏步迈向了自己未来的高富帅生活。  

尽管这个故事是虚构的，不反映任何真实历史。但小明在这里使用的编码方法，就是我们所熟知的 ASCII[^2] 的雏形。每个工程师和科学家都可以自己定义自己的编码方式，但为了交换数据方便，对文字的编码最终都会变成一项国家标准或者国际标准。ASCII 可以说是一切文字编码标准的源头，且深受其影响。  

## 4.2  字符集及其编码  

字符集（character set 或 charset），是为了表示某种语言文字而定义的字符集合；编码则是为了在计算机中表示某个字符集中的字符而设定的编码规则，它通常以固定的顺序排列字符，每个字符对应一个特定的字节或者字节序列，并以此作为记录、存储、传递、交换的统一内部特征。一般而言，字符集由某个国家或者国际标准化组织[^3]作为强制或推荐标准颁布。在字符集的定义当中，通常使用码值的概念，就是字符集当中各个字符的编号。比如在我们国家于 1980 年颁布的 GB2312-1980[^4] 字符集标准中，所定义的汉字/符号被分为87个区，每个区包含 94 个汉字/符号。这样，我们可以用特定汉字/符号在 GB2312 字符集中的哪个区、哪个位来指代它，这就是汉字“区位码”的概念。比如，“啊”字是 GB2312 中的第一个汉字，是第 16 区的第一个字符，它的区位码就表达为 1601，或者十六进制的 0x1001。我们将类似区位码的这种字符编号称为字符的“码值”。  

但是，在计算机中存储或者表示特定字符集中的字符时，我们需要考虑很多其他因素，最重要的就是兼容其它已有及基础字符集的问题，以及易于表达和处理的问题。这样，特定字符集中的字符，会以某个不同于字符码值的方式表示，这就是编码的概念。比如上面的 GB2312 字符集中的字符，大部分情况下使用后面提到的 EUC-CN 编码方法，这种方法用两个字节来表示一个汉字。其中，第一个字节的取值范围为 0xA1-0xF7（区位码中的区号加上0xA0），第二个字节的取值范围为 0xA1-0xFE（区位码中的位号加上 0xA0）。例如，“啊”字的 EUC-CN 编码就是 0xB0A1。需要注意的是，某些字符集本身定义了编码的方式，这种情况下，码值和编码是一样的。  

计算机领域中首次出现的字符集及其编码标准是 ASCII，即美国信息交换标准代码。该字符集编码最初由美国标准协会[^5]于 1968 年制定，并在之后成为国际标准化组织制定和颁布的 ISO 646 标准。ASCII 一共定义了 128 个字符，其中包含英语使用的 26 个小写拉丁字母和 26 个大写拉丁字母、阿拉伯数字、标点符号以及若干控制字符。在十六进制形式下，ASCII 使用 7 位字节来表示一个字符，取值范围从 0x00 到 0x7F。表 4-1 给出了 ASCII 字符的十六进制编码分布情况。  

<small>表 4-1 ASCII 字符的十六进制编码分布</small>  

| 取值或范围 | 代表字符      |  
|:-----------|:--------------|
| 0x00       | 空（NULL）字符，C 语言表达为 \0。  |  
| 0x01~0x1F  | 控制字符，其中 0x07~0x0D 为常用控制字符，分别表示蜂鸣（\a）、回退（\b）、水平制表符（\t）、新行（\n）、垂直制表符（\v）、进纸（\f）、回车（\r）等。  |  
| 0x20       | 空格。  |  
| 0x21~0x2F  | 感叹号等标点符号。  |  
| 0x30~0x39  | 阿拉伯数字0~9。  |  
| 0x3A~0x40  | 冒号等标点符号。  |  
| 0x41~0x5A  | 大写拉丁字母A~Z。  |  
| 0x5B~0x60  | 左右中括号等标点符号。  |  
| 0x61~0x7A  | 小写拉丁字母 a~z。  |  
| 0x7B~0x7E  | 左右花括号等标点符号。  |  
| 0x7F	     | 删除符（DEL）。  |  


注意表 4-1 中的 ASCII 字符的编码取值范围，我们很容易发现，小写拉丁字母和大写拉丁字母并不是连续排列的。也就是说，这 128 个字符的编码方式存在一些特殊的考量，如：  

- 给定一个大写的拉丁字母，通过对其编码做“或”0x20 的运算，得到的就是该字母的小写字符。比如对字母A，其编码值为 0x41，0x41 | 0x20 后的值为 0x61，得到的就是小写 a 的 ASCII 编码，反之亦然。这种设计，使得早期的机械键盘或者电子键盘可更加容易地实现按键的大小写切换；我们可以按住键盘上的换挡（Shift）键或者打开大写锁定（CapsLck）键来输入大写字母。当然，借助此编码特性，也方便我们在程序中实现快速的大小写字母转换。  
- 类似地，我们在 PC 键盘上看到的可通过换挡键切换输入字符的按键，在编码上也只有单个位的区别，比如 ! 和 1，在 PC 键盘上用单个按键输入，其编码分别为 0x21 和 0x31。  
- 除了字母、数字和标点符号之外， ASCII 中含包含了大量的控制字符。这些控制字符通常不是可打印字符，其主要用途有：1）用于在屏幕上显示或者打印时控制字符的输出位置（如换行、回车、制表符、送纸等）；2）用于交互输入场景（如蜂鸣、回退、删除）；3）用于串口通讯。第三类用途在当今已经非常少见了，只有在接近硬件的嵌入式系统开发才会遇到。  

显然，一个字符集及其编码的定义是并不是随意拼凑、排列的结果，而需要一些技巧。当然，字符集及其编码的定义也会受限于当时的计算机处理能力以及制定者在当时可以预见的未来。  

在计算机的应用范围扩大到全球各个地区的时候，仅仅使用 ASCII 无法满足非英语国家的需求。首先是经济较为发达的拉丁语系国家，ASCII 并没有包含法语、德语等拉丁语系以及西里尔语、阿拉伯语、希腊语、希伯来语使用的字母。为此，国际组织定义了 ISO 8859 系列字符集，作为 ASCII 字符集的扩展：  

- ISO 8859-1：西方欧洲语言（Latin-1）
- ISO 8859-2：中部和东部欧洲语言（Latin-2）
- ISO 8859-3：东南欧洲语言和其他语言（Latin-3）
- ISO 8859-4：斯堪的纳维亚语/波罗的语（Latin-4）
- ISO 8859-5：拉丁/西里尔语
- ISO 8859-6：拉丁/阿拉伯语
- ISO 8859-7：拉丁/希腊语
- ISO 8859-8：拉丁/希伯来语
- ISO 8859-9：Latin-1针对土耳其语的修订（Latin-5）
- ISO 8859-10：拉普兰/北欧/爱斯基摩人语（Latin-6）
- ISO 8859-11：拉丁/泰语
- ISO 8859-13：波罗的海沿岸语言（Latin-7）
- ISO 8859-14：凯尔特语（Latin-8）
- ISO 8859-15：西部欧洲语言（Latin-9）
- ISO 8859-16：罗马尼亚语（Latin-10）  

ISO 8859 系列标准所定义的字符集及其编码有如下特点：  

- 均为 ASCII 编码的扩展，使用八位单字节定义每个字符，除 ASCII 定义的字符之外，其余字符使用 0xA0\~0xFF 区间范围定义字符。也就是说，ISO 8859 系列字符集向前兼容 ASCII 字符集，且保留 0x80~0x9F 这个区间未被使用。  
- ISO 8859 系列字符集之间是互相不兼容的，但标准的制定者也为这些字符集中的公共字符定义了相同的编码值。  

在 ISO 8859 系列字符集中，最为重要的字符集是 ISO 8859-1 字符集。使用该字符集，可支持大部分拉丁语系语言，包括南非荷兰语、巴斯克语、加泰罗尼亚语、丹麦语、荷兰语、英语、法罗语、芬兰语、法语、加利西亚语、德语、冰岛语、爱尔兰语、意大利语、挪威语、葡萄牙语、苏格兰、西班牙语和瑞典语。下个小节中提到的 Unicode 字符集之前 256 个字符来自于 ISO 8859-1 字符集，且 Unicode 的 UTF-8 编码兼容 ASCII 字符集。  

对于上面提到的拼音文字（以拉丁语系为代表），基本上使用8位的单字节编码即可表达对应语言的所有文字。但对汉字为代表的象形文字，却无法使用单字节的编码形式来定义所有的文字，毕竟《康熙字典》收录的汉字就有大概四万多个。为了在计算机中方便处理以汉字为代表的语言文字，中国大陆、中国台湾、日本等国家在 ASCII 的基础上各自制定了自己的字符集及其编码标准。  

上面提到的 GB2312 标准就是中国定义的简体中文字符集标准，其中含有 682 个符号、6,763 个汉字；它共分 87 个区，每个区含 94 个字符。类似的还有日本的JISX0201、JISX0208 字符集，以及中国台湾、香港等地区广泛使用的 BIG5 繁体中文字符集等。  

一个字符集可以有不同的编码形式。拿 GB2312 字符集来讲，通常我们使用的是上面所讲的 EUC-CN 编码。还有一种常见的 GB2312 编码形式是 HZ 编码，它去掉了 EUC 编码的最高位，使得汉字可以用 ASCII 码中的字符来表示，比如 EUC 编码中的汉字“啊”编码为“0xB1A1”，而 HZ 编码则为“~{1!~}”。这种编码方式主要应用于早期互联网电子邮件系统，那时的电子邮件系统不能正确处理 ASCII 字符集之外的字符，所以人们使用 HZ 编码来传输汉字。当然，现在这种编码方式基本上不再使用了。  

在上个世纪 90 年代，随着个人计算机在国内的普及，GB2312 字符集定义的六千多个汉字远远不能满足互联网、出版界以及教育界的需求。最为尴尬的就是朱镕基总理的“镕”字没有被收录到 GB2312 字符集当中，导致在互联网刚刚进入中国时（1996年左右）的中文网页上，无法正确显示“镕”字。这种标准缺位的问题存在了很长一段时间。为了解决现实问题，微软在其 Windows 95 操作系统中自行扩展了 GB2312 字符集，纳入了 BIG5 字符集定义的繁体汉字以及其他一些常用汉字，称为 GBK。需要注意的是，该字符集并不是中国国家标准。另一方面，从上个世纪 90 年代开始，美国的主要 IT 巨头公司开始联合制定 Unicode 字符集，我国政府则自行制定了 GB18030 字符集，并要求所有在国内销售的操作系统必须支持 GB18030 字符集。从字符集定义的字符范围来看，GB18030 和 Unicode 类似，可用来定义海量的字符，且 GB18030 的编码方式向前兼容 GB2312 和 GBK。但时至今日，Unicode 及其 UTF-8 编码最终成为事实上的工业标准。这一字符集标准的争夺战及其发展历史，值得回味和反思。  

随着各个国家、地区字符集标准的出台和升级，兼容性问题的引入是不可避免的。比如，一个采用 GB2312 EUC-CN 编码的文本文件无法在采用 BIG5 编码的系统上正常显示，若要正常显示和处理，则需要额外进行字符集及编码的转换。为此，一些国际组织开始致力于全球统一字符集标准的开发，也就是我们熟知的 Unicode/ISO 10646。  

## 4.3  Unicode 字符集及 UTF-8 编码  

国际标准组织早在 1984 年 4 月就成立了 ISO/IEC JTC1/SC2/WG2 工作组，开始针对各国文字、符号定义统一的字符集及编码标准，即 ISO 10646 统计字符集（UCS[^6]）标准。于此同时，位于美国加州的主要 IT 巨头公司如微软、苹果、IBM、惠普等则成立 Unicode 组织来定义自己的 Unicode 字符集。  

1991 年 Unicode 组织变身为 Unicode 财团，并于当年 10 月与 ISO/IEC JTC1/SC2/WG2 达成协议，采用同一编码字符集，并密切协调各自标准的进一步扩展，同时公布了 Unicode 1.0。1997 年 9 月发布的 Unicode 2.0 是一个更为成熟的 Unicode 版本，并在各操作系统中广泛使用。自 Unicode 2.0 开始保持了向后兼容，即新的版本仅仅增加字符，原有字符不会被删除或更名。Unicode至今仍在不断增修，每个新版本都会加入更多新的字符。目前最新的版本为 2014 年 6 月 16 日公布的 7.0.0，已收入超过十万个字符（第十万个字符在 2005 年获采纳）。Unicode 8.0.0 将于 2015 年 6 月发布（已发布草案）。由于ISO 10646 统一字符集标准的扩展速度要比 Unicode 快，因此，人们通常认为前者是后者的超集。  

当前主流的操作系统（如 Linux、Windows 等）所支持的 Unicode 版本为 Unicode 3.0。Unicode 3.0 版本包含字母及符号 10,236 个，CJK（中日韩）汉字 27,786 个，韩文拼音 11,172 个，总的已分配字符为 49,194 个；另有保留私用码位 6,400 个，替代码位 2,048 个，控制字符 64 个、非字符 2 个；总分配码位 57,709 个，未分配码位 7,827，共计 65,536 个码位。  

Unicode 3.0 总共定义了 65,536 个码位（除去0xFFFE 和 0xFFFF 两个非字符的话则为 65,534 个码位），可使用 16 位字来表示一个字符，基本满足全球各个国家和地区的日常文字处理需要。但由于地球文明的多样性以及不断发现和涌现的文字及表意符号，最新的 Unicode 7.0 版本已经定义了超过十万个码位。而由国际标准组织定义的 ISO 10646 统一字符集标准之最新版本，甚至需要 31 位的码位空间才能表达所有的字符。  

在计算机程序中处理 Unicode 字符时，有多种编码方式。比如对 Unicode 3.0，我们可以使用 16 位字来表示单个字符，对应于 ISO 10646 标准的 UCS-2/UTF-16 编码方式，而针对 Unicode 7.0 等更大的字符集，则需要使用 32 位双倍字来表示单个字符，对应于 ISO 10646 标准的 UCS-4/UTF-32 编码方式。  

但是 UCS-2 和 UCS-4 这两种编码方式存在一些问题：  

- 在不同的计算机系统上，UCS-2 和 UCS-4 编码方式存在字节序问题。  
- UCS-2 编码的数据在 UCS-4 编码的系统上进行处理时，需要重新转换编码。  
- 大量使用 ASCII 字符集编码的计算机程序等已有的数据使用单字节编码，若使用统一的 UCS-2 或者 UCS-4 编码方式，将带来极大的内存浪费。  

为了解决这些问题，Unix、C 语言作者之一肯·汤普逊于 1992 年提出了 UTF-8 编码方式，并成为当前几乎所有互联网内容的主要编码方式。UTF-8 是一种针对 Unicode 的可变长度字节编码，属于一种前缀码。它可以表示 Unicode 标准中的任何字符，且其编码和 ASCII 兼容。其主要特性有：  

- UCS码位在 0x00000000 到 0x0000007F 之间的字符（即 ASCII 定义的字符）被简单编码为单个字节的 0x00 到 0x7F。这样，UTF-8 兼容 ASCII，也就是说，仅包含 7 位 ASCII 字符的文件和字符串在 ASCII 和 UTF-8 编码下的形式是一样的。
- 所有码值大于 0x7F 的 UCS 字符，将被编码为多字节序列，而且其取值范围为 0x80 到 0xFD。这样，ASCII 字符将不会出现在其他字符的编码范围中，而且不会影响空字符等控制字符的行为。
- UCS-4 字符串的词典排列顺序被保留。
- UCS 定义的所有 31 位码位均可被 UTF-8 编码。
- UTF-8 编码不使用 0xC0、0xC1、0xFE 和 0xFF 等字节。
- 单个非 ASCII 字符的 UTF-8 编码的多字节序列中，第一个字节的取值范围始终为 0xC2 到 0xFD，使用高位值为1的位数可给出该多字节序列的长度。其后所有字节的取值范围为 0x80 到 0xBF，这种编码方式在丢失字节的情况下，可保持解码的同步并使得解码过程健壮而无状态。
- 理论上，使用 UTF-8 编码 UCS 字符，其最大长度可达 6 个字节。但由于 Unicode 3.0 标准并未定义码值在 0x10FFFF 之上的字符，因此，Unicode 3.0 字符使用 UTF-8 编码时，其最大长度为 4 个字节。  

表 4-2 给出了 UCS 码值对应的 UTF-8 编码（二进制形式）。  

<small>表 4-2 UTF-8 编码</small>

| UCS 码值范围 		        | UTF-8 编码（二进制）        |  
|:-------------------------|:----------------------------|  
| 0x00000000 - 0x0000007F  | 0xxxxxxx                    |  
| 0x00000080 - 0x000007FF  | 110xxxxx 10xxxxxx           |  
| 0x00000800 - 0x0000FFFF  | 1110xxxx 10xxxxxx 10xxxxxx  |  
| 0x00010000 - 0x001FFFFF  | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  |  
| 0x00200000 - 0x03FFFFFF  | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx  |  
| 0x04000000 - 0x7FFFFFFF  | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx  |  

在上表中，UTF-8 二进制编码中的 xxx 位取自对应码值的二进制表述。比如版权符号（©）的 Unicode 码值为 0xa9，其二进制表述为 1010 1001，则其 UTF-8 编码为：11000010 10101001，亦即 0xc2 0xa9。

需要注意的是，UCS 码值在 0xD800 到 0xDFFFF 范围（即替代码位）以及 0xFFFE 和 0xFFFF 这两个非字符，不会出现在 UTF-8 编码字节流中。  

下面的 C 代码将给定的 UCS 码值转换成 UTF-8 编码：  

```c
static int utf8_conv_from_uc32 (UChar32 wc, unsigned char* mchar)
{
    int first, len;

    if (wc < 0x80) {
        first = 0;
        len = 1;
    }
    else if (wc < 0x800) {
        first = 0xC0;
        len = 2;
    }
    else if (wc < 0x10000) {
        first = 0xE0;
        len = 3;
    }
    else if (wc < 0x200000) {
        first = 0xF0;
        len = 4;
    }
    else if (wc < 0x400000) {
        first = 0xF8;
        len = 5;
    }
    else {
        first = 0xFC;
        len = 6;
    }

    switch (len) {
        case 6:
            mchar [5] = (wc & 0x3f) | 0x80; wc >>= 6; /* Fall through */
        case 5:
            mchar [4] = (wc & 0x3f) | 0x80; wc >>= 6; /* Fall through */
        case 4:
            mchar [3] = (wc & 0x3f) | 0x80; wc >>= 6; /* Fall through */
        case 3:
            mchar [2] = (wc & 0x3f) | 0x80; wc >>= 6; /* Fall through */
        case 2:
            mchar [1] = (wc & 0x3f) | 0x80; wc >>= 6; /* Fall through */
        case 1:
            mchar [0] = wc | first;
    }

    return len;
}
```  

另外，除了 UTF-8 编码之外，UCS 相关的编码还有 UTF-7、UTF-16、UTF-16LE、UTF-16BE、UTF-32、UTF-32LE、UTF-32BE 等。其中的 LE、BE 后缀分别表示小头字节序或者大头字节序。  

## 4.4  历史上曾使用过的其他文字编码体系  

在计算机技术发展，尤其是操作系统的发展过程中，在标准缺失的情形下，操作系统厂商或者计算机系统厂商经常为了满足特定地区的市场需求而自行制定一些字符集或者编码体系。如上面提到的 GBK 就是微软公司为中国大陆设计的兼容 GB2312 的字符集，后来成为事实上的标准，并影响了 GB18030 字符集的制定。尽管当前几乎所有的最新软件都开始使用 Unicode 尤其是 UTF-8 编码来处理文字，但仍然有大量资料使用老的字符集标准存储和交换。本小节将简单介绍一下历史上曾使用过的主要字符集及文字编码体系。  

### 4.4.1  EUC  

EUC 全称为 Extended Unix Code，即扩展 Unix 编码。顾名思义，EUC 和 Unix 操作系统相关。1991 年，Unix 操作系统相关公司制定了 EUC 标准，主要用于存储汉语文字、日语文字以及韩语文字。其中，  

- EUC-CN 是 GB2312 字符集的常用编码方法，亦即GB2312 的默认编码方法。这种编码方法兼容 ASCII。ASCII 字符使用 0x00~0x7F 单字节编码，GB2312 定义的其他字符使用两个字节来编码，第一个字节取值范围为：0xA1-0xF7，第二个字节的取值范围为：0xA1-0xFE。
- UC-JP 是日本 JIS X 0208 和 JIS X 0212 两个字符集的扩展 Unix 编码方法。和 EUC-CN 类似，ASCII 字符使用 0x00~0x7F 单字节编码，而使用两个字节或者三个字节来编码半角片假名（两个字节）、JIS X 0208 定义的字符（两个字节）以及 JIS X 0212 定义的字符（三个字节）。但在 Windows 和 IBM 的日语操作系统中，普遍使用 Shift_JIS 编码方法。
- EUC-KR 是韩国KS X 1001字符集的扩展 Unix 编码方法。和上面类似，ASCII 字符使用 0x00~0x7F 单字节编码，KS X 1001定义的其他字符使用两个字节来编码，两个字节的取值范围均为 0xA1-0xFE。
- EUC-TW 是针对中国台湾CNS 11643 字符集标准制定的扩展 Unix 编码方法。除 ASCII 字符之外，其他字符使用两个字节或者四个字节的来表示。不过，台湾、香港、澳门、新加坡、马来西亚等繁体中文通行的国家和地区广泛使用的是 BIG5（大五码）及其编码方法，几乎不使用 EUC-TW 编码。   

### 4.4.2  代码页  

代码页（Code Page）是特定字符集编码的别称，这个名称在微软、苹果和 IBM 的操作系统软件或者计算机系统中使用，如 DOS、Windows、Mac电脑、IBM 大型机等。比如 Windows 操作系统中的 CP936 代码页，对应的就是 GB2312 的 EUC-CN编码表。  

在Windows 95 等现代操作系统中，内部使用 Unicode 字符集的 UCS-2 编码进行字符的处理。但在 Unicode 尚未被完全普及的情形下，需要一个映射表将已有的 GB2312 等特定字符集编码情形下的文件或者字符串转为 Unicode 进行处理。通过切换不同的代码页，操作系统还可以支持不同的字符集及其编码处理。而在操作系统内部，这种映射表就称为代码页。  

## 4.5  文字编码的转换  

从前面的描述中可以看出，计算机系统为表述人类文字走过了一条复杂的道路。尽管当前 Unicode 的 UTF-8 编码已成为互联网上传输文字内容的事实标准，但因为历史原因，我们有大量的文字使用不同的字符集或者编码来保存。在国内，一些老的网站可能仍然使用 GB2312、GBK 等字符集及其编码来保存网页中的文字内容，这种情况下，网页浏览器就需要将这些不同字符集和编码的文字转换为 Unicode 然后再做进一步的处理。  

在当今流行的 Linux 操作系统中，我们可以使用 iconv 命令完成文字的字符集及其编码转换。比如将 EUC-JS 编码的文本转换为 Shift_JIS 编码的文本，或者转换为 UTF-8 编码的文本。iconv 是一个开源软件，开发者可在 C 程序中调用其接口完成转换，亦可在 PHP、Python 等各种脚本语言中使用经过封装的接口或者模块。  

显然，我们可以将前述 ISO-8859 系列、EUC 编码以及各种代码页下的文本转换为 Unicode 字符集的某种编码形式。但如果反过来，则可能无法正确转换，比如将某个汉字转换为 ASCII 码是行不通的。  

在 Unicode 的 UTF-8 和 UTF-16 等编码之间进行转换是相对直接的，下面的 C 语言代码段完成了一个 UTF-8 编码到 UCS4 编码之间的转换：  

```c
static Glyph32 utf8_char_glyph_value (const unsigned char* pre_mchar,
                int pre_len, const unsigned char* cur_mchar, int cur_len)
{
    UChar32 wc = *((unsigned char *)(cur_mchar++));
    int n, t;

    if (wc & 0x80) {
        n = 1;
        while (wc & (0x80 >> n))
            n++;

        wc &= (1 << (8-n)) - 1;
        while (--n > 0) {
            t = *((unsigned char *)(cur_mchar++));

            wc = (wc << 6) | (t & 0x3F);
        }
    }

    return wc;
}
``` 

对其他字符集编码到 Unicode 之间的转换，由于字符集制定者的设计思路的不同，导致文字的编码转换无法通过一个简单的公式来处理。比如，GB2312 中的汉字字符在设计上遵循按普通话拼音为顺序的原则排列，但在 Unicode 中，汉字字符按笔画数从小到大排列。这样，当我们要将一个 EUC-CN 编码的文字转换成 Unicode 编码时，需要使用映射表。  

下面的代码段使用 __mg_gbunicode_map 映射表中保存了六千多个 GB2312 字符对应的 Unicode UCS 码值。gb2312_0_char_glyph_value 函数则根据 EUC-CN 编码计算特定 GB2312 字符在 __mg_gbunicode_map 映射表中的索引值。  


```c
static Glyph32 gb2312_0_char_glyph_value (const unsigned char* pre_mchar,
                int pre_len, const unsigned char* cur_mchar, int cur_len)
{
    int area = cur_mchar [0] - 0xA1;

    if (area < 9) {
        return (area * 94 + cur_mchar [1] - 0xA1);
    }
    else if (area >= 15)
        return ((area - 6)* 94 + cur_mchar [1] - 0xA1);

    return 0;
}

const unsigned short __mg_gbunicode_map[] = {
0x3000, 0x3001, 0x3002, 0x30fb,
0x02c9, 0x02c7, 0x00a8, 0x3003,
0x3005, 0x2015, 0xff5e, 0x2225,
0x2026, 0x2018, 0x2019, 0x201c,
0x201d, 0x3014, 0x3015, 0x3008,
...
0x9eea, 0x9eef, 0x9f22, 0x9f2c,
0x9f2f, 0x9f39, 0x9f37, 0x9f3d,
0x9f3e, 0x9f44
};

static UChar32 gb2312_0_conv_to_uc32 (Glyph32 glyph_value)
{
    return (UChar32)__mg_gbunicode_map [glyph_value];
}
```  


[^1]: 其实这个方法现在还在用，比如你乘坐电梯时看到的楼层数字。   

[^2]: ASCII：American Standard Code for Information Interchange，美国信息交换标准代码。   

[^3]: 国际标准化组织：International Standard Orgnization，ISO。   

[^4]: 经常被简称为 GB2312 或者 GB2312-80。  

[^5]: 美国标准协会：United States of America Standards Institute，USASI。  

[^6]: UCS：Universal Character Set。  

