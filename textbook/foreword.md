# 引言

## 初衷和目标

和二十年前相比，计算机的处理能力已经有了成倍的增长。现在，几乎人手一部的智能手机的硬件配置或运算能力都要比二十年前的大型主机还要强。“全民编程”看似遥远而触不可及，但作为一个趋势，可能会在二三十年内变成现实。届时，编程有可能会成为中学的必修课或者小学高年级的选修课。然而，计算机技术的飞速发展，使得相关知识呈爆炸式增长。如何在纷繁复杂的计算机编程语言、操作系统或平台、技术词汇、新技术的海洋中做到游刃有余，将是新一代程序员需要面临的实际问题。

笔者从上个世纪 90 年代开始接触编程，曾在 DOS、Windows、Linux 等操作系统上，使用 C、C++、JavaScript、HTML、PHP、SQL 等多种编程语言开发各种各样的计算机程序。总结笔者几十年的编程经验，我发现，不论计算机技术如何发展，其实我们可以用一个比较清晰的脉络来总结计算软件的技术或者知识，掌握了这些知识点，你将有“一览纵山小”的感觉——任何一个程序员都可以相对快速地学习新的操作系统、平台或者编程语言，从而将主要精力放在自己的应用程序上，而不是平台或者编程语言的细节上。

迄今为止，尚未有一本这样的书，以科普的方法来阐述计算机程序和编程的内在实质。大部分计算机相关技术书籍主要讲述某个特定的技术，比如特定的编程语言或者特定的平台开发技术等等。而那些存在于几乎所有的平台和编程语言上的共性，却鲜有书籍来讲述，或者仅存在于大学的专业教科书中，而这些教科书大多纵向阐述知识，鲜有横向阐述知识的教科书。

另外，尽管我们尚未进入“全民编程”时代，但各种和科技相关联的行业研发人员，都需要进行或多或少的编程。对这些人员来讲，如果可以快速掌握基础的计算机技术相关知识点，少走弯路，也将成为相关企业或者科研单位在激烈的市场竞争中立于不败之地的重要助推因素。其实，就算是互联网等计算机行业，现在也有大量非计算机相关专业的毕业生在从事编程工作；而软件产品的设计人员（产品经理、视觉设计人员甚至运营人员），也需要了解一些基本的计算机技术。因此，本书涉及的内容对这些人员来讲，将非常有帮助。

更进一步，计算机相关技术的发展速度非常快，许多技术可能在很短的时间内（比如一两年）变得过时，甚至无人问津。但不管是什么样的技术，只要曾被大规模使用，都会是计算机技术发展过程中必然要走过的道路。如果我们在学习新技术之前知悉其演进历史，也将帮助我们正确理解新技术，从而让我们有一种豁然开朗的感觉。但由于各种原因，新的程序员未必知悉某个技术的前世今生，从而在某种程度上阻碍了我们对这些技术的正确把握，也不利于我们正确把握计算机技术发展的节奏或“心跳”。

因此，本书旨在揭示计算机程序和编程的内在本质，以及相关技术的发展演进过程，从而为读者呈现一个完整的、清晰的计算机软件相关技术的发展脉络及内在联系。同时，本书力求用浅显、简洁的语言来阐述相关的技术和知识点；笔者的目的是，只要读者具有高中的数学知识并且成功编写过几百行程序，就能看懂本书所讲内容。本书不包含深奥的数学推导或者复杂的图表，笔者力求仅通过文字和简单的示意图将看似高深的计算机软件相关理论知识展现在读者面前。笔者期望读者读取此书，是一种享受而不是煎熬。

当然，对笔者来讲，完成这个任务将是一项巨大的挑战。2015 年，笔者恰好有一段闲暇时间，故而写就了本书规划中的第一篇。现今是 2022 年，15 年到现在的 7 年间，这个世界发生了很多巨大的变化，其中对中国影响最深远的，应该就是中美之间剑拔弩张的科技竞争了。如果放在这个历史背景下考量，这本书的内容对中国基础软件行业，甚至是整个信息技术行业进而辐射到全部的科技行业，都具有非常重要的历史意义。

然而，一个人的精力毕竟有限。笔者还有很多同等重要的事情要做，比如 HVML 编程语言的开发，MiniGUI 的更新和维护以及用来糊口的生计等等。故而，我希望更多的人能够参与到这本书的撰写当中。就如同 2020 年，几个人通过协作撰写了中国第一部码农体长篇小说《考鼑记》一样。

## 编程的瓶颈

尽管计算机软件技术的发展可以用一日千里来形容，但如果我们仔细看其发展历史，会发现，基础的东西并没有变化多少。比如，C 语言和 UNIX 在上个世纪七十年代末发明出来，到现在已经有三十多年的历史，但从发明到现在，这两样东西并没有太大的变化，而且仍然非常流行。再比如，R 语言专为统计和绘制统计图表而诞生于上个世纪八十年代，很长一段时间内，很多人不知道有这样一种编程语言，但随着大数据的流行，R 语言再次被使用并发挥着巨大的作用。

另一方面，大量科学研究和开发人员开始使用各种各样的工具和编程语言编写计算机程序。虽然学习一门编程语言并使用该语言编写程序的门槛越来越低（毕竟大量的书籍、开源软件、专业博客站点、[问答网站][1]等为我们提供了最短的学习路径），但是，程序的质量并没有太大提升。当然，程序质量的度量本身是一个比较复杂的事情，但我们可以从越来越庞大的程序包，复杂的源代码规模，运行起来的速度越来越慢并出现卡顿、掉线等各种作为用户的切身体会中感受到：大量的程序并没有经过良好的设计和优化。

究其原因，是因为大部分程序员仅依赖于自己的“直觉”进行编程——他们仅仅将编程的重点放在功能而非性能、源代码的易读性、设计上的可扩展性、团队协作上的可维护性、规模上的可伸缩性等等方面。这就是当前程序员普遍遇到的编程瓶颈。

在移动互联网时代，市场竞争如此激烈，占得先机圈用户成了大部分互联网企业或创业团队的第一目标。甚至 Facebook 还提出了“Done always better than perfect”（其含义是“实现始终强于完美”）。进而，“先实现再优化”变成了一种流行的软件工程方法。笔者本人赞同这种软件工程方法，毕竟一个软件产品的开发过程涉及多种人员，如果有一个原型实现，然后再讨论改善要比纸上谈兵好很多。但是，遵循“先实现再优化”的原则，并不是说一开始就不需要设计以及必要的[优化][2]考量。

但如果我们只看到这一句话，那就会被大大地误导。要知道，Facebook 这种大公司的工程师水平应该是世界一流的，所以，就算是采纳这种策略，软件产品的质量也不会差到哪里去。

后来，作为对此原则的补充，Facebook 在 2013 年时提出了“[全栈工程师][3]”的概念，并声称 Facebook 只招聘全栈工程师。显然，Facebook 也意识到，只有从一开始就将软件设计上的普遍规律深深植入到软件产品中，才能保证软件产品在一开始不会出现大的技术纰漏。

而这些软件设计上的普遍规律就是本书要讲述的内容。一个软件工程师，必须将这些普遍性的知识和规律根植到自己的大脑中，才能锻炼自己成为一名“全栈工程师”，或者起码成为一名高级软件工程师，一名不仅仅依赖“直觉”编程的工程师，才能在面对新的技术时可以从容应对，快速学习并掌握这些新的技术。当然，这些基础的知识也可以为我们的日常工作提供帮助，帮助我们提高工作效率。

有一次，笔者所在的公司需要从一个有千万条记录的数据库表中抽取一些记录并将其保存到另外一个表中。一名指派完成此项工作的工程师好几天加班加点却没有丝毫进展。笔者感觉非常奇怪，仔细一看发现，因为符合条件的记录在整个表中非常稀疏（大概只占10%左右），将这些记录使用 SQL 语句查询出来将耗费大量的服务器资源，甚至会[影响][4]数据库其他功能的正常运行。另外，因为是从远程计算机上执行查询的，因此，如果一个查询的结果集非常大，将带来数据的[传输问题][5]。如何既高效又在不影响现有数据库功能的要求下完成此项工作就成了棘手的问题。

最终，我们使用了分段查询的方法解决了这一问题。简单来讲，就是按照记录的插入时间一天一天处理这些记录的子集，而恰好记录的插入时间字段是有索引的。这样，查询的结果集将变小，服务器资源占用将变小。在此基础上，使用 Python 语言编写一段不超过100行的程序，即可让其循环执行，从而完成此项工作。

在上面这个案例中，假如数据库表中的记录只有几十条，要完成类似的工作，大部分程序就会使用“直觉”进行编程，因为数据量非常少，不会遇到任何性能或者数据传输上的问题。问题将发生在面对千万条或更多记录的情况。假如完成此项工作的程序员恰好没有相关经验，那这个问题可能要耗上一两天时间还无法找到问题的症结所在，而且他可能会将时间花费在其他方面，比如：

- 他会怀疑是不是 Python 语言或者使用的模块有问题？于是可能会换成 PHP 或者其他语言来完成这个工作，而为了学习这些语言或者找到适当的操作函数库，又要花费大量的时间。他不知道，一个普遍使用的语言或者模块，就算有缺陷，也早就被人发现并解决掉了，这方面的怀疑几乎没有任何价值。
- 是不是网络配置上的原因导致网络传输发生中断？于是会调整各种网络参数，试图让传输可以正常完成。他不知道，远程获得大型查询结果集的问题，早就可以通过游标这种东西解决。
- 如此等等……

显然，没有相关基础知识，不了解软件或程序的普通规律的工程师，最大的问题就在于无法从根本上快速定位问题所在，甚至将大量时间浪费在其他方面。

根据笔者从业几十年的观察，当前程序员缺乏的并不是如何灵活使用某种编程语言，而是一些最基本的计算机软件基础知识。这些基础知识就算是计算机专业毕业的工程师，也鲜有全面掌握的。这在很大程度上将阻碍我们国家的信息技术发展。考虑到“全民编程”时代可能首先在美国成真，这本书的出现已“时不我待”！

## 本书内容的组织

归根结底，计算机程序所处理的东西是数据，或者用更加准确的词来讲就是“信息”。因此，本书将从信息的表述、存储、处理、传输、展现等角度阐述相关的技术或者知识。同时，还将用独立的篇章阐述编程语言、操作系统以及软件工程相关的内容。

每一篇最后一章，笔者将总结相关主题的基础方法，其中包括相关技术的演进和进化目标。计算机相关技术（包括硬件和软件技术）在快速演进，最近几年的演进速度尤其快，这和生物的进化有一些类似之处。我们了解计算机软件相关技术，最终目的是通过掌握“术”来把握其中的“道”，这也是笔者撰写这本书的主要目的。

在重要的计算机科学相关历史人物第一次出现时，本文会使用脚注的形式给以简单描述人物的主要贡献。在相关术语第一次出现时，会使用括号给出对应的英文术语。为了准确理解一些术语，本书附录B还给出了重要或易混淆的术语之解释，可供读者查阅。附录 C 则给出了全书所有代码或程序的快速查询索引，以方便读者查找。

除引言、序言、后记及附录外，本书共分七篇，各篇章节如下：

- 第一篇：信息的计算机表述。计算机归根结底是为人服务的，所以，信息的计算机表述实质上追求的是一种“人机共读”的境界。一方面，我们期望计算机可以非常容易地理解人，但另一方面，因为物理机制的限制，计算机又无法做到这一点。如此一来，计算机软件技术的发展过程其实就是追求极致“人机共读”境界的过程。
   - 第 1 章 为什么是二进制？
   - 第 2 章 二进制及其运算。
   - 第 3 章 数：整数及浮点数。
   - 第 4 章 文字：字符集及编码。
   - 第 5 章 多媒体：图像及音视频。
   - 第 6 章 抽象对象及结构化数据。
   - 第 7 章 有关信息表述的方法总结。
- 第二篇：信息的计算机存储。没有存储的计算机寸步难行。记忆不仅仅是为了持久保存一样东西，记忆也是完成一项计算任务的重要手段。
   - 第 8 章 文件系统。
   - 第 9 章 关系数据库。
   - 第 10 章 NoSQL 数据库。
   - 第 11 章 分布式存储。
   - 第 12 章 有关信息存储的方法总结。
- 第三篇：信息的计算机处理。处理信息是计算机的核心功能。而为了让计算机更快、更好地处理信息，科学家和工程师设计了各种方法。
   - 第 13 章 常见算法。
   - 第 14 章 压缩及加密。
   - 第 15 章 大数据处理。
   - 第 16 章 人工智能。
   - 第 17 章 有关信息处理的方法总结。
- 第四篇：信息的计算机展现。这部分内容仍然和“人机共读”相关联，但更加具体。
   - 第 18 章 字体。
   - 第 19 章 矢量图形。
   - 第 20 章 HTML 及 CSS。
   - 第 21 章 图形界面及交互。
   - 第 22 章 典型文件格式。
   - 第 23 章 有关信息展现的方法总结。
- 第五篇：信息的计算机传输。沟通是人类的本质需求。计算机之间的数据传输需求带来了互联网的发明及发展，而信息洪流的出现又极大促进了计算机和互联网技术的发展。
   - 第 24 章 互联网及 TCP/IP 协议。
   - 第 25 章 常见应用层协议。
   - 第 26 章 远程过程调用及数据随动。
   - 第 27 章 物联网及相关传输协议。
   - 第 28 章 有关信息传输的方法总结。
- 第六篇：计算机编程语言。编程语言的本质上就是不同的编码规则，是为了将算法变成“人机共读”之物而努力的结果。
   - 第 29 章 编程语言的本质及分类。
   - 第 30 章 面向对象编程。
   - 第 31 章 Web 编程。
   - 第 32 章 设计新的编程语言。
- 第七篇：操作系统。操作系统是现代计算机软件体系中最关键的“栈”。操作系统管理计算机系统资源的方式，体现了人类博大无边的智慧思想：分类归纳、抽象……
   - 第 33 章 通用操作系统。
   - 第 34 章 实时操作系统。
   - 第 35 章 智能设备操作系统。
   - 第 36 章 操作系统的本质及未来。
- 第八篇：软件工程方法。你不是一个人在战斗。软件工程探寻的是一种将软件的开发工程化的方法。在短短几十年的软件发展史中，人类已经找到了多种组织软件开发的软件工程方法，但没有哪一种是放之四海而皆准的。
   - 第 37 章 软件工程方法的演进。
   - 第 38 章 敏捷开发模型。
   - 第 39 章 开源软件及开源协作模型。
   - 第 40 章 没有唯一、普适的软件工程方法。
- 第九篇：计算机软件技术的发展热点。计算机软件接下来将走向何方？世界上顶尖的科学家或工程师正在试图解决什么样的计算机软件问题？
   - 第 41 章 新的编程语言。
   - 第 42 章 新的WEB开发技术或框架。
   - 第 43 章 下一代操作系统。
   - 第 44 章 人工智能及大数据。
   - 第 45 章 云计算。
   - 第 46 章 虚拟化技术。
- 后记：计算机软件技术发展的哲学思考。
- 附录 A：伪代码及其语法。
- 附录 B：重要或易混淆术语。
- 附录 C：程序或算法索引。

（下面是原来规划的内容。这些内容被整合到第九篇中了。）

- 第八篇：虚拟化技术。既然编码是一种映射，那为何不能让一个操作系统运行在另外一个操作系统上呢？甚至，让硬件用软件模拟？虚拟化技术就是解决这一问题的。
   - 第 35 章 虚拟化技术概述。
   - 第 36 章 软件虚拟化技术（Virtual Box、Kvm、Xen 及 Docker 等）。
   - 第 37 章 硬件虚拟化（Qmenu）。
   - 第 38 章 计算机仿真。
   - 第 39 章 云计算。
- 第九篇：大数据处理。微信朋友圈开始展示广告了！屌丝看到的是“可口可乐”，白富美看到的是“香奈儿”，高帅富看到的是“宝马”…
   - 第 39 章 互联网时代的数据大爆发。
   - 第 40 章 MapReduce。
   - 第 41 章 Hadoop 及 Spark。
- 第十篇：人工智能。人类很矛盾，一方面期望机器能和人一样啥事儿都能做，一方面又害怕有朝一日机器会取代人类，甚至毁灭人类。不过还不用着急，我们先看看现在的机器和人有多大的差距。
   - 第 47 章 从专家系统到人工神经网络。
   - 第 48 章 从模式识别到机器知觉、情感。
   - 第 49 章 机器学习及自主意识。
   - 第 50 章 深度学习。

## P 语言及程序片段

为说明某些程序处理方法，本书需要使用代码来描述对应的处理逻辑或算法。大部分情况下，笔者使用伪代码（pseudocode）程序。本书使用的伪代码之详细语法描述可参阅附录A。注意，本书某些小节所阐述的问题可能仅出现在（或仅适应于）特定的编程语言，如 C 语言或其他编程语言当中，此种情况下，相关内容会组织成为独立的小节。如果这些特定的编程语言不是您所熟知的，则可以跳过对应的小节，等需要了解的时候再来阅读不迟。

整体上，本书所使用伪代码语言属于强类型函数式语言，其语法规则主要来自于 C 语言、Python 语言以及 JavaScript 语言。为适应网络及书本页面，便于读者阅读，该语言有如下特点：

- 强类型语言。要求每个变量都要明确定义其类型。
- 大小写敏感，且使用大写来表示关键词，如 FUNCTION，IF 等；在本书中，变量、函数名等使用小写字母。
- 使用缩进来控制代码的逻辑块，避免使用过多括号或者关键词，每条语句行尾不使用分号。

为描述方便，我们将本书使用的伪代码语言称为 [P 语言][6]。以下通过示例简要描述该语言特性，更详细的描述请参阅本书附录A。
作为示例，我们给出一段输出[斐波那契][7]数列的 P 语言程序。在数学上，斐波那契数列就是 0, 1, 1, 2, 3, 5, 8 这种形式的数列，其规律是从第三个数开始，后面的数是前两个数的和。我们可以使用递归函数定义这个数列：


使用上述递归函数，我们输出斐波那契数列的 P 语言程序如下所示：

```
    1. FUNCTION VOID output_fibonacci (WORD first = 0, WORD second = 1)
    2.     WORD third = first + second
    3.     IF (third < second)
    4.         RETURN
    5. 
    6.     STDIO.printl ($third)
    7.     output_fibonacci (second, third)
    8. 
    9. output_fibonacci ()
```

该代码的第1行到第 7 行定义了一个函数（FUNCTION），其名称为 `output_fibonacci`。该函数接受两个 WORD 类型（16位二进制正整数）的参数，但不返回任何值。这个函数的两个参数均有默认值，分别为 0 和 1，这就是斐波那契数列的两个初始值。在这个函数中，程序首先计算新的斐波那契数（第 2 行），并赋值给 `third` 这个变量。第 3 行在形式上是判断 `third` 是否小于 `second`（IF 语句），但其实是在判断两个 WORD 类型参数的加法是否出现了溢出。如果出现溢出情况，则函数将返回，否则调用 STDIO 类提供的 `printl` 函数打印新产生的 `third` 的值（其中使用了 P 语言的 `$` 运算符，该运算符将给定的参数转换成十进制文本，即字符串），然后再次（递归）调用本函数。递归调用时，将 `second` 作为第一个参数传入，而 `third` 作为第二个参数传入。

在上面代码的第 9 行，程序没有传入任何参数调用了 `output_fibonacci` 函数。

这段代码的执行将从第 9 行开始（第 1 行到第 7 行的代码定义了 `output_fibonacci` 函数，仅在调用该函数时才会执行），其输出大致如下：

```
1
2
3
5
8
13
21
34
55
89
144
233
377
610
987
1597
2584
4181
6765
10946
17711
28657
46368
```

这段代码对应的 C 语言程序如下所示，熟悉 C 语言的读者可以自行对比：

```c
#include <stdio.h>

typedef unsigned short WORD;

void output_fibonacci (WORD first, WORD second)
{
        WORD third = first + second;
        if (third < second)
                return;

        printf ("%d\n", third);
        output_fibonacci (second, third);
}

int main (void)
{
        output_fibonacci (0, 1);
}
```

除了递归方法依次产生斐波那契数列之外，我们还可以通过如下[数学公式][8]计算给定位置的值：

相应 P 语言程序如下：

```
FUNCTION DWORD get_fibonacci (DWORD n)
    IF (n <= 0)
        RETURN 0
    IF (n = 1)
        RETURN 1

        FLOAT constant_a = (1 + MATH.sqrt(5)) / 2
        FLOAT constant_b = (1 – MATH.sqrt(5)) / 2
        FLOAT constant_c = MATH.sqrt(5) / 5
        FLOAT fib = (constant_c * (MATH.pow (constant_a, n) – \
MATH.pow (constant_b, n))

        RETURN (DWORD)fib
}

BYTE i
FOR (i = 2; i < 25; i++)
    STDIO.printl ($get_fibonacci (i))
```

上述代码定义了 `get_fibonacci` 函数，该函数根据斐波那契数列的序数计算对应位置的斐波那契数，其中使用 MATH 类提供的数学计算函数，如 `sqrt`、`pow` 等。在主执行代码中，使用 FOR 循环调用 `get_fibonacci` 函数，并使用 STDIO 类提供的 `printl` 函数输出了计算获得的斐波那契数。上述代码的执行效果和递归计算斐波那契数列的代码是一样的。

下面的代码展示了如何使用 P 语言的数组来生成斐波那契数列：

```
WORD[] fibs = [0, 1]

BYTE i
FOR i IN RANGE (2, 24)
    fibs [] = fibs[-2] + fibs[-1]
```

其中，`WORD[]` 定义了一个 WORD 类型的数组；`FOR i IN RANGE (2, 24)` 等价于上面的 `FOR (i = 2; i < 25; i++)` 语句。另外，`fibs [] =` 用于向 `fibs` 数组追加一个新的成员，`fibs[-2]` 和 `fibs[-1]` 分别引用了 `fibs` 数组中倒数第二个成员和最后一个成员。

## 常用的软件文档记法

在计算机软件文档中，有一些常用的约定俗成的记法。比如我们在 Windows 系统中查看某个命令的用法时，经常会看到下面的内容：

    C:\>HELP REN

    重命名文件。

    RENAME [drive:][path]filename1 filename2.
    REN [drive:][path]filename1 filename2.

    请注意，您不能为目标文件指定新的驱动器或路径。

上面的程序输出告诉用户 `REN` 命令的用法。请注意第四行和第五行中使用中括号（`[]`）括起来的部分。中括号表示对应的部分是可选的，而未使用中括号的部分（`filename1`、`filename2`），表示在实际的应用场合中，需要使用真实的字符串来替换。按照上面提供的用法，如下的 DOS 中 `REN` 命令用法是正确的：

```dos
C:\>REN \Windows\Temp\ABitMap.ini abitmap.ini
C:\>RENAME C:\Windows\Temp\ABitMap.ini abitmap.ini
```

我们再来看一个更加复杂点的例子，这个例子是 Linux 操作系统的 `cp` 命令用法说明：

    NAME
           cp - copy files and directories

    SYNOPSIS
           cp [OPTION]... [-T] SOURCE DEST
           cp [OPTION]... SOURCE... DIRECTORY
           cp [OPTION]... -t DIRECTORY SOURCE...

    DESCRIPTION
           Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.
    …

上面的内容来自 `cp` 命令的手册页（man page）。该手册页解释了 `cp` 命令的用途及详细用法，在 `SYNOPSIS`（原语）一节中给出了 `cp` 命令的三种形式（使用 `cp --help` 命令也可以获得类似的信息）。和 DOS 的帮助信息类似，Linux 的手册页也使用了中括号表示命令行中的可选部分，另外还使用了冒号表示命令行中特定的部分可以有多个，比如选项可以有多个，源文件可以有多个。下面这些 `cp` 命令的用法是正确的：

```bash
$ cp –t d a b c
$ cp a b c d/
```

根据手册页的描述，上面两种形式的 `cp` 命令完成的功能是一样的，都是将 `a`、`b`、`c` 这三个文件复制到 `d/` 目录下。

在一些更加严格的场合，为了防止和内容中不能更改的部分（比如上面的 `REN`、`cp` 等）混淆，还经常使用尖括号（`<>`）来表示必选部分，比如：

    cp [OPTION]...  <SOURCE>... <DICTIONARY>

使用省略号的情形也可以用星号（*）或加号（+）来表示。使用星号时，表示可有可无，使用加号时表示至少有一个。按此记法，上面的命令原语可写成：

    cp [OPTION]*  <SOURCE>+ <DICTIONARY>

上面使用星号和加号要比原先的省略号定义了更加严格的规则：OPTION 部分可有可无，SOURCE 部分则至少需要有一个。

另外，我们还可以使用管道符（|）来表示多个可选部分二选一或者多选一，如：

    man -K [-w|-W] [-S list] [-i|-I] [--regex] [section] term ...

本质上，这些计算机软件文档中经常用到的记法，其实来自于正则表达式。有关正则表达式的详细信息，可参阅本书第三篇“信息的计算机处理”。

## 引用说明

本书部分引用了来自[维基百科][9]、百度百科的相关内容，尤其在涉及人物和历史方面。这些被引用的内容通常会明显标记或者说明。

[1]: # "如知名的 www.StackOverFlow.com 网站。"
[2]: # "软件的优化一词可以从很多角度理解或定义。让程序变得更快是一种比较常见的理解。但在今天，优化一个程序或软件，大致包含如下几个层面的含义。第一，优化代码使之占用更少系统资源，这涉及让程序运行得更快，或者使用一些技巧提高交互的反馈速度等；第二，程序代码的可维护性，这要求程序设计的分层、分模块实现使之结构清晰，且源代码易读并具有较高的可扩展性；第三，采用恰当的技术路线和其他辅助软件来加快软件的开发，使之具有很强的可扩展性，以适应可能的用户爆发增长。"
[3]: # "全栈工程师这一概念在国内还存在许多不同的理解，但大部分是误解。普遍的误解是将全栈工程师等同于“万金油”，什么都要懂，什么都要精。显然这是不可能的，工程界不存在这样的“完人”。如果说存在，那也是人家可以比其他人更快地学习新的知识，或者更快地发现问题症结所在，并快速给出解决方案。"
[4]: # "这是因为，就算在可以标识需抽取的记录对应的字段上设置索引，由于该种记录非常稀疏，索引将会失效，从而相关的查询语句仍然要执行全表扫描来完成。对有千万条数据的关系型数据库表来讲，全表扫描将占用大量的处理器和内存资源。"
[5]: # "大部分关系型数据针对远程网络连接设置了一次可传输的包大小限制，从而在传输有大量结果集的过程中会遇到网络传输中断的情形。"
[6]: # "本书编写完成之时，就是P 语言从伪代码语言演进称为真正可以使用的编程语言之时。"
[7]: # "【维基百科】在西方，最先研究这个数列的人是意大利人斐波那契（Leonardo Fibonacci），他描述兔子生长的数目时用上了这数列。斐波那契有很多特性，其中之一是相邻两个数的比值趋近于黄金分割比：1.618。"
[8]: # "这个公式很有意思，使用无理数运算，结果却是整数。"
[9]: # "在本书编撰过程中，笔者同时修改了维基百科某些词条中存在的一些错误。"

