# 第 3 章  数：整数、浮点数及定点数  

发明计算机的初衷就是为了替代人来进行复杂、繁重的工程计算问题。本章将讲述计算机如何表述数的世界。需要注意的是，由于计算机使用离散的二进制数来表示实数，所以，计算机处理实数只能获得近似的结果，但这对一般的工程计算而言已经足够了。当然，绝对的精确是不存在的也是没有必要的。就拿圆周率来讲，小数点后10位就足够日常使用了。  

## 3.1  整数  

之前看到，我们可以使用二进制的字节、字、双字等表示从 0 开始的有限的正整数，这非常自然。比如一个字节，其可以表达的整数范围在 0~0xFF 之间，也就是 [0, 255]。在此基础上，我们可以完成整数的基本运算。但问题马上来了，我们如何使用字节、字、双字来表达负整数？  

一个比较容易想到的解决办法是使用将字节、字、双字的取值范围一分为二，除了0之外，一部分表示正整数，一部分表示负整数。这时，二进制的最高位（MSB）来可用来表示符号，比如负数时，MSB 为 1，正整数的 MSB 为 0。这样，我们用 0~0x7F 的范围可表示 [0, 127] 这个区间的 0 和正整数，用 0x80 ~ 0xFF 的范围来表示 [-128, -1] 这个区间的负整数。对后一种情况，0x80 表示 -128 还是 0x80 表示 -1 是一个需要仔细考量的问题。  

所幸的是，根据二进制运算的一些特性，我们发现用 0xFF 表示 -1、0x80 表示 -128 更为合理。比如，如果将 0xFF 和 0x01 看成是正整数，则 0xFF + 0x01 的结果应是 0x0100，而这个结果的低八位值（0x00），刚好是将 0xFF 看成 -1 时的结果。这就是补码（complement number）的来由。也就是说，我们可以通过补码的方式来确定一个正整数的负值表达。在使用字节时，0x01 的补码是 0xFF，则 0xFF 用来表达 -1；0x02 的补码是 0xFE，则 0xFE 可表达 -2，依此类推。  

对字、双字、双倍字等其他长度的二进制数，补码原理也一样适用。在我们的伪代码 P 语言中，使用 `INT` 类型来表示数学上的整数。和其他语言类似，整数类型在 16 位系统上的取值区间是 [-32,768, 32,767]、在 32 位系统上的取值区间是 [-2,147,483,648, 2,147,483,647]、而在 64 位系统上的取值区间是 [-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]。  

在下一章“文字：字符集及其编码”中，我们将给出一段 P 语言程序，该程序可以将一个使用二进制补码形式表达的整数转换为十进制表达的 100、-100 这种形式（文本字符串）。  

## 3.1.1  整数运算  

一般的编程语言针对整数提供有四则运算、取模（相除的余数）及比较逻辑运算。在 P 语言中，用以表示整数的数据类型是 INT，在 32 位系统上对应双字，在 64 位系统上对应四倍字。另外，我们可以将 P 语言的字节、字、双字、四倍字等类型分别看成是8位、16位、32位、64 位的无符号整数，将这些数据类型转换成 `INT` 型时，会根据补码规则转换为对应的有符号整数。  

下面的 P 语言代码段，给出了一个判断给定的整数是否为素数（质数）的 P 语言函数：  

```
FUNCTION BOOL is_prime (INT x)
    IF (x <= 1)
        RETURN false

    INT i = 2

    # 从 2 开始试除 x，当 (i ^ 2) 大于 x 时结束。
    WHILE ((i * i) <= x)
        # 判断 i 是否可以整除 x，使用取模运算。当余数为 0 就表明可被整除。
        IF ((x % i) == 0)
            RETURN true
        i = i + 1

    RETURN true
```  

`is_prime` 函数接受一个整数型参数 `x`，通过试除法判断该整数是否为素数。  

在整数运算中，需要特别注意溢出的情形。溢出是指，运算的结果超出了给定类型的表达范围。比如下面的代码：  

```
BYTE b = 0xF1 + 0x0F
```  

执行上述语句后，b 的值将为 0x01，但我们期望的应该是 0x0101。这是因为要表达 0x0101 这一二进制数，需要至少 9 位，但 BYTE 数据类型只能表示 8 位二进制数。类似地，整数的乘法、减法以及除法运算都可能出现溢出的情形，这里除法溢出的情形特指被 0 除的情况。  

在当今流行的电子计算机处理器设计中，整数四则运算的溢出通常通过指令执行结果的状态位（这种情形下使用溢出位来判断是否出现溢出）来表示，而被零除的情形则通过中断或者陷阱的形式通知程序。  

为应对普通的溢出情况，我们可以将两个字组合成一个单位在 16 位处理器上进行 32 位整数的运算，或者在 32 位处理器上进行 64 位整数的运算。比如下面的代码演示了如何在 32 位系统上执行两个 64 位整数的加法及减法运算：  

```
FUNCTION INT[] add_64b_int (INT[] augend, INT[] addhead)


FUNCTION INT[] substract_64b_int (INT[] minuend, INT[] substrahead)
```

上面的代码使用 `INT` 型数组（两个单元）在 32 位系统上表示 64 位的（有符号）整数。这段代码特别考虑了有符号整数的处理。   

在支持多种长度整数类型的编程语言（如 C 语言），编译器可以帮我们完成类似上面的额外处理工作，从而在编写程序时，程序员只需要处理运算过程中是否会出现溢出情形以及被零除的情形。  

对于被零除的情形，在使用高级语言进行编程的时候，我们可捕捉程序产生的异常（处理器通过中断或陷阱来通知此种情形的发生。在现代操作系统中，操作系统会处理被零除的中断或陷阱，如果正在执行的程序没有做相应的处理，则会终止这个程序的运行）。当然，最好的办法应该是检查算法，避免出现被零除的情况。在支持异常处理的语言（如 P 语言）中，我们可使用类似下面的代码来处理这种异常：  

```
TRY
    a = a / 0
CATCH (DividedByZeroError e)
    STDIO.printl ("Exception: Integer divided by zero.")
```  

在汇编语言或者比较低级的语言（如 C 语言）中，则需要通过使用中断处理器或信号处理器来完成相应的处理。相关详情可参阅本书第XX章“现代操作系统”。  

### 3.1.2  C 语言中的整数类型  

C 语言的 C99 规范为整数定义了 `char`、`short`、`int`、`long`、`long long` 等多种类型。这些整数类型在不同的处理器上使用不同的长度，如表 3-1 所示。  

<center><small>表 3-1  C 语言的整数类型及其长度</small></center>

<br>

| 类型          | 32 位处理器  | 64 位处理器  |
|:-------------|:------------|:------------|
| char         | 8           | 8           |
| short        | 16          | 16          |
| int          | 32          | 32          |
| long         | 32          | 64          |
| long long    | 64          | 64          |
  

根据上表，要在 64 位处理器上使用 64 位整数运算，需要将整数定义为 `long` 型而不是 `int` 型。  

在 C 语言中，为避免出现整数的运算溢出，一般的做法是适当选择整数类型，尤其在中间计算过程中。比如下面的函数：  

```
int multiply_divid (int multiplier_a, int multiplier_b, int divider)
{
    long product = (long) multiplier_a * multiplier_b;
    return (int)(product/divider);
}
```  

上面的 C 函数在计算 `multiplier_a` 和 `multiplier_b` 的乘积时，将其中一个转换成了 `long` 型（另外一个乘数会被隐式转换为 `long` 型），这是因为两个 32 位的整数相乘其结果有可能会溢出。当然，这个函数最终返回的结果仍有可能是溢出的（试想 `product` 被 1 整除的情形）。值得一提的是，在某些处理器上，有专门完成上述运算的指令。  

## 3.2  浮点数  

和整数不同，浮点数在计算机中的表达方式相对复杂很多。从数学上看，计算机中的整数只能用来表示有限范围中的自然数、整数和/或负数。如果要利用计算机进行实数（无限小到无限大，包含有理数，也包含无理数等）范围内的运算，则必须采用某种方式来表示实数。显然，使用基于字节为处理单元的现代计算机技术，是无法精确表达任意一个实数的，因此，我们必须采用某种方式来近似所要处理的任意实数，从而获得在一定范围内可以接受的运算精度。浮点数就是用计算机表达实数的一种方式，这种方式仍然采用有限多个字节的位数来表示单个实数，因此，其表达精度受到限制，但这种浮点数的表达方式，可以用计算机最容易理解的方式存储实数，从而可以在一定程度上提高实数的运算速度。我们也可以这样理解：浮点数是计算机表示实数时，在精度和性能之间的一种折衷结果。本小节将向大家简单介绍浮点数的类型以及存储格式。  

### 3.2.1  浮点数的类型及表述  

目前广泛使用的浮点数是由 IEEE（电气电子工程师协会）定义[^1]的，总共有四种浮点数，分别是单精度（32位）、双精度（64位）、扩展精度（80位）和四倍精度（128位）。  

在计算机中，存储浮点数的基本思路如下：  

- 将任意一个实数，其绝对值都可以转换为 X*2^E 形式，其中X 称为尾数，E 称为指数或者“阶）。如果我们限定 X 必须大于等于 1 小于 2 ，则对任意一个实数来讲，上述表达形式都将是唯一的。这一过程也称为实数的正规化。  

- 利用单个位来表示实数的符号，即正实数还是负实数。符号位为 0 时表示正数，符号位为 1 时表示负。  

这样，一个浮点数就由三个部分组成：表示正负的单个符号位、指数（E）以及尾数（X）。注意尾数，因为我们已经将尾数限定在大于等于1而小于2的范围内了，因此，其实尾数表示的是减去 1.0 之后的有效小数，存储时也仅仅存储有效小数。另外，考虑到指数可能为正，也可能为负，因此，在存储指数时，要先加上一个偏移量；对单精度浮点数，偏移量为 127（0x7F），对双精度浮点数，偏移量为1023（0x3FF）。不同精度的浮点数，除了指数和尾数所占的位数不同以外，没有其他区别。比如单精度浮点数，指数占 8 位，尾数占 23 位，符号位占1位；双精度浮点数，指数占11位，尾数占53位，符号位占1位。下面的公式给出了单精度浮点数转换成十进制时的计算方法：  


```
d = (-1)^S * (1 + X) * 2^(E - 127)
```

通过这样一种方式表示实数时，不同大小的实数其阶数会不一样，这也是浮点（float）这个名称的来由。另外，浮点数还有几种特殊表达方式：  

- 实数 0：全部位均为 0。符号位为 1 时称为负零，即 -0.0。  

- 无限大数：指数位全部为 1，尾数位全部为 0，符号位表示正无穷和负无穷，分别用 `INF` 和 `–INF` 表示。  

- 如果指数 达到最大可能值，且尾数非 0，这个数表示为 `NaN`（非实数），比如 -1.0 的平方根就是 `NaN`。  

注意无限大的定义。浮点数的无限大其实是相对的。比如对单精度浮点数而言，能够有效表示的实数是在 (-2*2^256, 2*2^256) 这个范围内，因此，超过这个范围的实数都将成为单精度浮点数中的负无穷或者正无穷；而对其他精度的浮点数，正无穷和负无穷的定义就会相应改变。因此，我们要根据自己的浮点运算可能范围来决定采用哪种精度的浮点数进行运算。  

表 3-2 给出了两个示例，表明两个实数的单精度浮点数表达。  

<center><small>表 3-2 单精度浮点数的表达</small></center>   
 
| 十进制   | 正规化    | 符号  | 偏移后的指数      | 减去 1.0 之后的尾数           |
|:--------|:---------|:-----|:----------------|:----------------------------|
| -12     | -1.1x23  | 1    | 1000 0010(0x82) | 01000000 00000000 00000000  |
| 0.25    | 1.0x2-2  | 0    | 0111 1101(0x7D) | 00000000 00000000 00000000  |


为了更进一步理解浮点数的表达形式，下面我们将给定的单精度浮点数转换成十进制。假定给定的单精度浮点数表示为：0x49E48E68，则：  

1) 其第31位为0，即S= 0；
2) 第30～23 位依次为100 1001 1，转换成十进制就是147，即N = 147。 
3) 第22～0 位依次为110 0100 1000 1110 0110 1000，也就是二进制的纯小数0.110 0100 1000 1110 0110 1000。因此，其十进制形式为：  

<div align="center">

(0.110 0100 1000 1110 0110 1000 * 2^23)/(2^23)  

=(0x49E48E68 & 0x007FFFFF)/(2^23)=(0x648E68)/(2^23)

= 0.78559589385986328125

</div>


即 X = 0.78559589385986328125。这样，该浮点数的十进制表示为：

<div align="center">

= (- 1)^S \* (1 + X) * 2(N - 127)

= (- 1)^0 \* (1 + 0.78559589385986328125) * 2^(147 - 127)

= 1872333  

</div>


在浮点数的应用中，我们需要注意，我们常见的十进制表达的有限不循环小数不能用二进制浮点数做精确表达，因为我们要将这些实数使用 2 的阶数而不是 10 的阶数表示。因此存在误差，在经过一定的浮点数运算之后，这种误差会扩大。比如 0.1 和 0.01[^2]，0.01 是 0.1 的平方。在单精度浮点数中，表示 0.1 的最接近的数是：

<div align="center">

0.100000001490116119384765625

</div>

对此数做平方运算，其结果是

<div align="center">

0.10000000298023226097399174250313080847263336181640625

</div>

但最接近 0.01 的二进制浮点数却是：

<div align="center">

0.009999999776482582092285156250

</div>

### 3.2.2  浮点数的字节序  

在特定架构上存储浮点数时，和整数一样，也存在字节序的问题。表 3-3 给出了浮点数的常见字节序以及对应的典型架构。  

<center><small>表 3-3 浮点数常见字节</small></center>  

<br>

| 浮点数字节序     |	典型架构	         | 示例 <br>(1.2345678e10的单精度浮点数表达） |
|:---------------|:-----------------|:-------------------------------------|
| 标准小头	     | Intel 的 IA32     |	00 00 80 c5 e0 fe 06 42            |
| 标准大头	     | Motorola 的 M68k  |	42 06 fe e0 c5 80 00 00            |
| 大头字、小头字节  |	ARM	             | e0 fe 06 42 00 00 80 c5             |


### 3.2.3  浮点数运算  

对比整数和浮点数，浮点数的运算效率要低很多。为了提高运算速度，一些处理器通过浮点协处理器来完成浮点数的基本运算（如四则运算及比较运算），但浮点协处理器的设计往往要比简单的二进制加法器复杂很多，且功耗较大。因此，浮点协处理器并不是当前处理器的标配，毕竟大量的浮点运算仅出现在工程领域。在英特尔的 IA 架构处理器上，一般会包含有浮点协处理器，但也有例外，比如针对移动设备或者笔记本设计的英特尔处理器就不包括浮点协处理器，而智能手机使用的基于 ARM 架构的处理器基本上不包括浮点协处理器。对于后者，往往通过软件来实现浮点数的运算。但不论是否有浮点协处理器，对高级编程语言来讲，我们不需要知悉底层软件或计算机系统到底使用的是浮点协处理器还是软件实现，它们之间的最大区别就是运行速度会有显著差异。  

根据浮点数相关规范[^3]，浮点数的支持需要实现如下基本运算：  

- 加减乘除四则运算。在加减运算中负零和零相等，即：-0.0 = 0.0。
- 平方根（sqrt）。约定 sqrt(-0.0) = -0.0。
- 浮点数圆整（round）。近似到最近的整数，如果恰好在两个相邻整数之间，则近似到偶数。
- 浮点余数。相当于 x - (round(x / y) * y)。
- 比较运算。  

在基本运算基础之上，我们可以通过数学方法（如级数展开）获得特定实数的非线性函数值，如对数、三角函数等。对浮点协处理器来讲，这些基本运算就形成了协处理器的指令集。而在基本运算基础之上通过软件实现的数学处理函数集合则形成了数学函数库，其中包含求对数、求幂、求正弦等各种常见函数。在 C 语言中，这些数学函数库由 C99 定义和规范化，并作为其他高级编程语言的基础。比如，在 P 语言当中，求解正弦值的函数（sin） 由 MATH 类提供，按如下方法调用：  

```
FLOAT f = MATH.sin (3.14)
```  

### 3.2.4  C 语言中的浮点数  

目前，C 语言通常提供三种浮点数类型，分别是：  

- C 语言类型为 `float`，用来表示 32 位单精度浮点数，占 4 个字节；
- C 语言类型为 `double`，用来表示 64 位双精度浮点数，占 8 个字节；
- C 语言类型为 `long double`，该类型表示的浮点数和平台相关。通常来讲，在 32 位处理器平台上，该类型表示 80 位的扩展精度浮点数，占 10 个字节；而在 64 位处理器平台上，该类型表示 128 位的四倍精度浮点数，占 16 字节。  

目前，几乎所有的C 语言数学库都会遵循 C99 规范提供相关接口。C99 规范为不同的浮点数类型定义了相同运算的不同接口。比如，C99 规范为 `float`、`double` 和 `long double` 类型分别定义了计算余弦值的函数接口：  

```
       #include <math.h>

       double cos(double x);
       float cosf(float x);
       long double cosl(long double x);
```  

因此，我们在使用符合 C99 规范的数学库时，需要根据不同的浮点数类型来调用不同的函数接口。  

另外，目前某些平台上的格式化输入和输出函数，如 `printf/scanf` 等，尚不能提供对 `long double` 浮点数的正确支持，因此，读者在使用 `long double` 时应该注意到这一点。  

## 3.3  定点数  

### 3.3.1  定点数的概念  

在没有浮点协处理器的计算机系统上，如果要进行大量的浮点数运算，其性能会很低。因此，人们想到了另外一种办法来满足高性能实数计算的需求，也就是使用定点数。  

定点数其实很好理解。比如在会计处理中，我们可以将表示现金的数字全部乘以 100，然后再进行计算。这时，原本需要浮点数的运算就变成了整数运算，将结果再除以 100，余数就是角和分。  

因此，定点数实质上是整数。我们始终用整数中给定不变的位数来表示一个实数的整数部分，然后用其余的位来表示实数的小数部分（而浮点数的整数部分和小数部分所占的位数会根据实数的值发生变化）。这样，如果用定点数来表示实数，则四则运算可用整数的四则运算来处理，其他的非线性运算（比如平方根、立方根、三角运算等）则可以用查表法得到。  

这种基于定点数的运算，存在如下优点和缺点：  

- 运算速度非常快。因为大多数的运算实质上是整数运算，或者简单的线性查表运算，因此，定点数的运算速度和整数运算相当。  

- 可表示的实数范围有限，且精度较低。比如，如果我们的定点数小数部分只有 4 位，则精度只能达到小数点后两位。  

由于定点数运算的范围和精度有限，因此，定点数通常用于运算结果被限定在某个区间中的情形。比如，在图形学中，表示一个像素值的 RGB 分量取值区间是有限的（[0,255]），此时，如果采用定点数进行像素的混合运算，则其结果是可接受的。  

### 3.3.2  定点数的 C 语言实现  

在 32 位计算机上，我们可以使用带符号的 32 位整数来表示一个定点数，取值范围从 -32767.0 到 32767.0；一个定点数用高 16 位表示符号及实数的整数部分，用低16位表示小数部分。类似地，在 64 位计算机上，我们可以使用 64 位整数来表示一个定点数，其取值范围和精度将大大超过 32 位系统。  

使用 C 语言，浮点数和定点数之间相互转换的函数可以如下实现：  

```
typedef int fixed;

static inline fixed ftofix (double x)
{
   if (x > 32767.0) {
      errno = ERANGE;
      return 0x7FFFFFFF;
   }

   if (x < -32767.0) {
      errno = ERANGE;
      return -0x7FFFFFFF;
   }

   return (long)(x * 65536.0 + (x < 0 ? -0.5 : 0.5));
}

static inline double fixtof (fixed x)
{
   return (double)x / 65536.0;
}
```  

注意，上述函数使用 C 语言的全局 errno 来表示可能出现的超出运算范围等情形。因此，在调用这些函数之后，应该检查 errno 是否有被设置，并在出现错误的情形下做相应处理。  

相比浮点数，整数和定点数之间的转换函数更为简单：  

```
static inline fixed itofix (int x)
{
   return x << 16;
}

static inline int fixtoi (fixed x)
{
   return (x >> 16) + ((x & 0x8000) >> 15);
}
```  

这样，定点数的加减运算就变成了整数的加减运算；如下是定点数加法运算：  

```
static inline fixed fixadd (fixed x, fixed y)
{
   fixed result = x + y;

   if (result >= 0) {
      if ((x < 0) && (y < 0)) {
         errno = ERANGE;
         return -0x7FFFFFFF;
      }
      else
         return result;
   }
   else {
      if ((x > 0) && (y > 0)) {
         errno = ERANGE;
         return 0x7FFFFFFF;
      }
      else
         return result;
   }
}
```   

定点数的乘除法运算要相对麻烦一点，要仔细处理符号位以及小数部分相乘的进位问题，如下所示：  

```
fixed fixmul (fixed x, fixed y)
{
    int s1 = 1, s2 = 1;
    long result;
    unsigned long op1_hi;
    unsigned long op1_lo;
    unsigned long op2_hi;
    unsigned long op2_lo;
    unsigned long cross_prod;
    unsigned long prod_hi;
    unsigned long prod_lo;

    if (x < 0) {
        s1 = -1;
        x = -x;
    }

    if (y < 0) {
        s2 = -1;
        y = -y;
    }

    op1_hi = (x >> 16) & 0xffff;
    op1_lo = x & 0xffff;
    op2_hi = (y >> 16) & 0xffff;
    op2_lo = y & 0xffff;
    cross_prod = op1_lo * op2_hi + op1_hi * op2_lo;
    prod_hi = op1_hi * op2_hi;
    if(prod_hi > 0x7FFF){
        errno = ERANGE;
        return 0x7FFFFFFF;
    }
    prod_lo = ((op1_lo * op2_lo) >>16) + cross_prod;

    prod_hi = (prod_hi << 16) + prod_lo;
    if(prod_hi > 0x7FFFFFFF){
        errno = ERANGE;
        return 0x7FFFFFFF;
    }
    result = s1 * s2 * prod_hi;

    return (fixed)result;
}
```  

对求平方根、三角运算等非线性运算则采用查表法实现。以平方根为例，该实现首先构造了一个 0~256 值的平方根线性表：  

```
static unsigned short _sqrt_tabl[256] =
{
   0x2D4,   0x103F,  0x16CD,  0x1BDB,  0x201F,  0x23E3,  0x274B,  0x2A6D,
   0x2D57,  0x3015,  0x32AC,  0x3524,  0x377F,  0x39C2,  0x3BEE,  0x3E08
   ...
   0xF7E3,  0xF867,  0xF8EA,  0xF96E,  0xF9F1,  0xFA74,  0xFAF7,  0xFB79,
   0xFBFB,  0xFC7D,  0xFCFF,  0xFD80,  0xFE02,  0xFE82,  0xFF03,  0xFF83
};
```  

然后利用如下数学公式推导，我们可将任意实数的平方根转化为依赖于上述线性表的四则运算：  

```
因为：sqrt (x) = sqrt (x/d) * sqrt(d)
设：d = 2^(2n) 
则：sqrt (x) = sqrt (x / 2^(2n)) * 2^n
```  

在最后的等式中，只要将等式右边的 sqrt 运算限制到 0~255 之间，我们就可以利用在上面给出的 0 ~ 255平方根表中查表获得对应的值，再乘以 2^n 即可得到 sqrt (x) 的值。这样，找到 n 就可以仅仅通过查表和乘法运算计算出 sqrt (x)。而从十六进制的运算规律可知，x / 2^(2n) 恰好相当于将 x 右移 2n 位之后的值。因此，我们只需要知道将 x 右移多少位之后小于 256，即可得到 2n 的值。有了上述推导，定点数的 sqrt 函数实现方式如下：  

```
fixed fsqrt(fixed x)
{
    int i, dx;
    int cx = 0;             /* if no bit set: default %cl = 2n = 0 */

    /* 判断负值... */
    if (x <= 0) {
        if (x < 0)
            errno = EDOM;
        return 0;
    }

    /* bit-scan is done on dx */
    dx = x >> 6;
    for (i = 0; i < 32; i++) {
        if (dx << i & 0x80000000) {
            cx = 32 - i;
            break;
        }
    }

    cx &= 0xFE;             /* 确保结果为偶数 -->  %cl = 2n */
    x >>= cx;               /* 右移 x 使其取值范围在 0..255 之间 */

    x = _sqrt_tabl [x];     /* 查表... */

    cx >>= 1;               /* %cl = n */
    x <<= cx;               /* `sqrt(x/2^(2n))' 乘以`2^n' */

    return x >> 4;          /* 调整结果 */
}
```  

## 3.4  任意精度运算  

由于浮点数和定点数在实数表达上存在的缺点（浮点数在表示大数的时候会损失小数部分的精度，而定点数的表达范围有限且小数部分的精度也是有限的），仍无法满足某些领域的运算要求。因此，人们又发明了用于任意精度运算的程序或函数库。当然，任意精度运算本质上仍然是有限精度运算，只是其可以表达的精度范围随着计算机可以使用的内存可以无限制增长。  

因为任意精度运算的应用场合较窄，因此尚未形成业界标准。现今，主要的任意精度运算由 GNU 项目的两个开源（自由）软件实现：  

bc（bench calculator），是一种运行在 UNIX 类操作系统上的任意精度计算器程序，可支持2,147,483,647 位小数点位数。该程序支持类似 C 语言的语法，可编程表达计算公式。  

GMP（GNU Multiple Precision Arithmetic Library，GNU 多精度运算库，简称 GMP），是使用 C 语言开发的多精度运算函数库，可支持整数、有理数以及浮点数，其精度仅受限于可用内存。GMP 可用于密码应用和研究、互联网安全应用、代数系统以及计算代数研究等等。  

[^1]: 【维基百科】在1980年，英特尔公司就推出了单片的8087浮点数协处理器，其浮点数表示法及定义的运算具有足够的合理性、先进性，被IEEE采用作为浮点数的标准，于1985年发布。而在此之前，浮点数的二进制表示混乱而缺乏统一标准。 

[^2]:  这个例子取自【维基百科】。

[^3]:  即 IEEE 754。

